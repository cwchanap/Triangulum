name: Unit Tests

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  unit-tests:
    runs-on: macos-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Run Unit Tests
        run: |
          set -o pipefail
          SIMULATORS_JSON="${RUNNER_TEMP}/simulators.json"
          xcrun simctl list devices available -j > "$SIMULATORS_JSON"
          SIMULATOR_UDID=$(python3 -c "import json,sys; data=json.load(sys.stdin); runtimes=data.get('devices',{}); ios_devices=[d for key, devices in runtimes.items() if ('iOS' in key or 'SimRuntime.iOS' in key) for d in devices if d.get('isAvailable')]; iphones=[d for d in ios_devices if 'iPhone' in d.get('name','')]; pick=(iphones or ios_devices); print(pick[0]['udid'] if pick else '')" < "$SIMULATORS_JSON")
          if [ -z "$SIMULATOR_UDID" ]; then
            echo "No available iOS simulators detected."
            xcrun simctl list devices available
            exit 1
          fi
          DESTINATION="platform=iOS Simulator,id=$SIMULATOR_UDID"
          RESULT_BUNDLE="${RUNNER_TEMP}/triangulum-tests.xcresult"
          if command -v xcpretty >/dev/null 2>&1; then
            xcodebuild test -project Triangulum.xcodeproj -scheme Triangulum -destination "$DESTINATION" -enableCodeCoverage YES -only-testing:TriangulumTests -resultBundlePath "$RESULT_BUNDLE" | xcpretty
            RESULT=${PIPESTATUS[0]}
          else
            echo "xcpretty not found; using raw xcodebuild output"
            xcodebuild test -project Triangulum.xcodeproj -scheme Triangulum -destination "$DESTINATION" -enableCodeCoverage YES -only-testing:TriangulumTests -resultBundlePath "$RESULT_BUNDLE"
            RESULT=$?
          fi
          if [ $RESULT -ne 0 ]; then
            echo "xcodebuild failed. Extracting test failures from xcresult..."
            export XCRESULT_JSON="${RUNNER_TEMP}/triangulum-tests.json"
            SUMMARY_JSON="${RUNNER_TEMP}/triangulum-tests-summary.json"
            if ! xcrun xcresulttool get test-results summary --legacy --path "$RESULT_BUNDLE" --compact > "$SUMMARY_JSON"; then
              echo "xcresulttool test-results summary failed (legacy)."
              xcrun xcresulttool get test-results summary --path "$RESULT_BUNDLE" --compact > "$SUMMARY_JSON" || true
            fi
            if [ -s "$SUMMARY_JSON" ]; then
              python3 -c $'import json,sys\npath=sys.argv[1]\ntry:\n    with open(path,"r",encoding="utf-8") as handle:\n        data=json.load(handle)\nexcept Exception as exc:\n    print(f"Failed to parse summary JSON: {exc}")\n    sys.exit(0)\n\nfailures=data.get("testFailures") or []\nfailed=data.get("failedTests",0)\ntotal=data.get("totalTestCount",0)\nprint(f"Summary: {failed} failed / {total} total")\nif failures:\n    print("Failing tests (summary):")\n    for failure in failures:\n        name=failure.get("testName","")\n        target=failure.get("targetName","")\n        text=failure.get("failureText","")\n        if target:\n            print(f"- {name} ({target}): {text}")\n        else:\n            print(f"- {name}: {text}")\nelse:\n    print("No test failures in summary.")' "$SUMMARY_JSON"
            fi
            if ! xcrun xcresulttool get object --legacy --path "$RESULT_BUNDLE" --format json > "$XCRESULT_JSON"; then
              echo "xcresulttool legacy mode failed to read $RESULT_BUNDLE"
              xcrun xcresulttool get object --path "$RESULT_BUNDLE" --format json > "$XCRESULT_JSON" || true
            fi
            if [ -s "$XCRESULT_JSON" ]; then
              python3 -c $'import json,sys\npath=sys.argv[1]\ntry:\n    with open(path,"r",encoding="utf-8") as handle:\n        data=json.load(handle)\nexcept Exception as exc:\n    print(f"Failed to parse xcresult JSON: {exc}")\n    sys.exit(0)\n\nfailures=[]\n\ndef walk(obj):\n    if isinstance(obj, dict):\n        name=obj.get("testName",{}).get("_value") if isinstance(obj.get("testName"), dict) else obj.get("testName")\n        text=obj.get("failureText",{}).get("_value") if isinstance(obj.get("failureText"), dict) else obj.get("failureText")\n        if name and text:\n            failures.append((name, text))\n        for value in obj.values():\n            walk(value)\n    elif isinstance(obj, list):\n        for item in obj:\n            walk(item)\n\nwalk(data)\nif failures:\n    print("Failing tests (xcresult scan):")\n    for name, text in failures:\n        print(f"- {name}: {text}")\n' "$XCRESULT_JSON"
            else
              echo "xcresult JSON not available; skipping failure scan."
            fi
          fi
          exit $RESULT

      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-results
          path: |
            ${{ runner.temp }}/triangulum-tests.xcresult
            ${{ runner.temp }}/triangulum-tests.json
            ${{ runner.temp }}/triangulum-tests-summary.json
          if-no-files-found: warn

      - name: Install xcresultparser
        if: always()
        run: brew install xcresultparser

      - name: Export Coverage Report
        if: always()
        run: |
          RESULT_BUNDLE="${RUNNER_TEMP}/triangulum-tests.xcresult"
          COVERAGE_DIR="$GITHUB_WORKSPACE/coverage"
          COVERAGE_REPORT="$COVERAGE_DIR/cobertura.xml"
          if [ ! -d "$RESULT_BUNDLE" ]; then
            echo "No xcresult bundle found at $RESULT_BUNDLE"
            exit 0
          fi
          if ! xcrun xccov view --report "$RESULT_BUNDLE" >/dev/null 2>&1; then
            echo "No coverage report available in $RESULT_BUNDLE"
            exit 0
          fi
          mkdir -p "$COVERAGE_DIR"
          xcresultparser --output-format cobertura --project-root "$GITHUB_WORKSPACE" "$RESULT_BUNDLE" > "$COVERAGE_REPORT"
          cp -R "$RESULT_BUNDLE" "$COVERAGE_DIR/triangulum-tests.xcresult"

      - name: Upload Coverage Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-results
          path: coverage
          if-no-files-found: warn

  codecov:
    name: Upload Coverage to Codecov
    runs-on: macos-latest
    needs: unit-tests

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download coverage results
        uses: actions/download-artifact@v4
        with:
          name: coverage-results
          path: coverage-results

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          files: coverage-results/cobertura.xml
          disable_search: true
          verbose: true
          token: ${{ secrets.CODECOV_TOKEN }}
